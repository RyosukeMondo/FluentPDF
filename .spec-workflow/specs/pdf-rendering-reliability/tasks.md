# Tasks Document

## Phase 1: Core Infrastructure

- [x] 1. Create core interfaces and data models
  - Files: src/FluentPDF.Core/Interfaces/IRenderingStrategy.cs, src/FluentPDF.Core/Models/RenderingModels.cs
  - Define IRenderingStrategy interface with TryRenderAsync method
  - Create data models: RenderContext, MemorySnapshot, MemoryDelta, SafeHandleLeak, RenderingDiagnostics
  - Purpose: Establish contracts for rendering strategies and observability data structures
  - _Leverage: Existing pattern from IDocumentService, existing model patterns from FluentPDF.Core_
  - _Requirements: 1, 2_
  - _Prompt: Implement the task for spec pdf-rendering-reliability, first run spec-workflow-guide to get the workflow guide then implement the task: Role: .NET Architect specializing in interface design and domain modeling | Task: Create IRenderingStrategy interface defining the contract for rendering approaches (TryRenderAsync method returning Task<ImageSource?>, StrategyName and Priority properties) and create comprehensive data models (RenderContext with document/page context, MemorySnapshot with memory metrics, MemoryDelta with deltas, SafeHandleLeak for leak detection, RenderingDiagnostics for operation results) following requirements 1 and 2. Place interface in src/FluentPDF.Core/Interfaces/IRenderingStrategy.cs and models in src/FluentPDF.Core/Models/RenderingModels.cs. | Restrictions: Do not add implementation code in interface file, keep models as immutable records, ensure all models are serializable for logging, follow existing namespace conventions (FluentPDF.Core.Interfaces, FluentPDF.Core.Models), do not introduce dependencies on WinUI types in Core project | Success: IRenderingStrategy interface clearly defines rendering contract with XML documentation, all data models are complete with all required properties, models use record types for immutability, no compilation errors, follows existing Core project patterns. After implementing, update tasks.md to mark this task as [-] in progress, then use log-implementation tool to record what was created, then mark task as [x] completed._

- [x] 2. Implement RenderingObservabilityService
  - File: src/FluentPDF.App/Services/RenderingObservabilityService.cs
  - Create service with structured logging for rendering pipeline stages
  - Implement BeginRenderOperation returning IDisposable for automatic timing
  - Add methods: LogRenderSuccess, LogRenderFailure, LogUIBindingFailure
  - Purpose: Centralized observability for entire rendering pipeline
  - _Leverage: Existing Serilog ILogger<T> injection pattern, existing structured logging from other services_
  - _Requirements: 1, 5_
  - _Prompt: Implement the task for spec pdf-rendering-reliability, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior .NET Developer specializing in observability and structured logging | Task: Implement RenderingObservabilityService in src/FluentPDF.App/Services/RenderingObservabilityService.cs with comprehensive logging for rendering pipeline following requirements 1 and 5. Inject ILogger<RenderingObservabilityService> and MemoryMonitor. Implement BeginRenderOperation that returns IDisposable (use nested RenderOperationScope class) to automatically log start/end with timing. Add LogRenderSuccess(operation, duration, outputSize), LogRenderFailure(operation, exception, diagnostics), LogUIBindingFailure(propertyName, diagnostics) methods. Use structured logging with Serilog enrichment properties (OperationName, PageNumber, DocumentName, Duration, OutputSize). | Restrictions: Do not directly reference WinUI UI types, keep service in App layer not Core layer, use existing ILogger<T> injection pattern, ensure thread-safe logging, do not block rendering pipeline with logging overhead (async where possible), follow existing service patterns in FluentPDF.App | Success: Service implements comprehensive logging for all rendering stages, BeginRenderOperation provides automatic timing and cleanup, structured logging includes rich context properties, service is registered in DI container, no performance regression. After implementing, update tasks.md to mark this task as [-] in progress, then use log-implementation tool to record the service class and methods created, then mark task as [x] completed._

- [x] 3. Implement MemoryMonitor utility
  - File: src/FluentPDF.App/Services/MemoryMonitor.cs
  - Implement CaptureSnapshot to record memory state (working set, private memory, managed heap, handle count)
  - Implement CalculateDelta to compare snapshots and detect abnormal growth
  - Implement DetectSafeHandleLeaksAsync to enumerate SafeHandles and check for leaks
  - Purpose: Track memory usage and resource leaks during rendering operations
  - _Leverage: System.Diagnostics.Process.GetCurrentProcess(), GC.GetTotalMemory(), existing SafeHandle types_
  - _Requirements: 5_
  - _Prompt: Implement the task for spec pdf-rendering-reliability, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Performance Engineer specializing in .NET memory management and diagnostics | Task: Implement MemoryMonitor in src/FluentPDF.App/Services/MemoryMonitor.cs for tracking memory usage and resource leaks following requirement 5. Implement CaptureSnapshot using Process.GetCurrentProcess() for WorkingSet64, PrivateMemorySize64, GC.GetTotalMemory(false) for managed memory, and Process.HandleCount. Implement CalculateDelta to compare two snapshots and return MemoryDelta with IsAbnormal flag (threshold: >100MB delta for single page, >1000 handle delta). Implement DetectSafeHandleLeaksAsync (note: full leak detection is complex, implement basic version that just logs current handle count and memory). | Restrictions: Do not add significant memory overhead (keep allocations under 1MB per operation), do not block rendering threads with expensive diagnostics, handle Process.GetCurrentProcess() disposal properly, do not depend on WinUI types, ensure thread-safe snapshot capture, follow existing service patterns | Success: MemoryMonitor accurately captures memory metrics, delta calculation correctly identifies abnormal growth, snapshot operations complete in <10ms, service is lightweight and doesn't impact performance, handles are properly disposed. After implementing, update tasks.md to mark this task as [-] in progress, then use log-implementation tool to record the utility class and its methods, then mark task as [x] completed._

- [x] 4. Register services in dependency injection container
  - File: src/FluentPDF.App/App.xaml.cs
  - Add RenderingObservabilityService as singleton to DI container
  - Add MemoryMonitor as singleton to DI container
  - Purpose: Make new services available throughout application
  - _Leverage: Existing service registration pattern in ConfigureServices method_
  - _Requirements: All (infrastructure for all features)_
  - _Prompt: Implement the task for spec pdf-rendering-reliability, first run spec-workflow-guide to get the workflow guide then implement the task: Role: .NET Developer with expertise in dependency injection and service configuration | Task: Register new services in DI container in App.xaml.cs ConfigureServices method. Add services.AddSingleton<RenderingObservabilityService>() and services.AddSingleton<MemoryMonitor>(). Ensure services are registered in correct order (MemoryMonitor before RenderingObservabilityService since latter depends on former). | Restrictions: Do not modify existing service registrations, maintain singleton lifetime for stateless services, follow existing registration patterns in ConfigureServices, ensure no circular dependencies, keep registration code clean and organized | Success: Services are properly registered and resolvable from DI container, application builds without errors, services can be injected into ViewModels and other services, no runtime dependency resolution errors. After implementing, update tasks.md to mark this task as [-] in progress, then use log-implementation tool to record the DI registration changes, then mark task as [x] completed._

## Phase 2: Rendering Strategies

- [x] 5. Extract WriteableBitmapRenderingStrategy from existing code
  - File: src/FluentPDF.App/Services/RenderingStrategies/WriteableBitmapRenderingStrategy.cs
  - Extract current WriteableBitmap + ImageSharp rendering logic from PdfViewerViewModel
  - Implement IRenderingStrategy interface
  - Set Priority = 0 (highest priority, try first)
  - Purpose: Isolate current rendering approach into strategy pattern
  - _Leverage: Current rendering code from PdfViewerViewModel.RenderCurrentPageAsync, ImageSharp usage_
  - _Requirements: 2_
  - _Prompt: Implement the task for spec pdf-rendering-reliability, first run spec-workflow-guide to get the workflow guide then implement the task: Role: .NET/WinUI Developer with expertise in image processing and strategy pattern | Task: Extract WriteableBitmap rendering logic from PdfViewerViewModel into new WriteableBitmapRenderingStrategy class implementing IRenderingStrategy following requirement 2. Create new file src/FluentPDF.App/Services/RenderingStrategies/WriteableBitmapRenderingStrategy.cs. Copy the ImageSharp decoding and WriteableBitmap creation code from PdfViewerViewModel (lines around 710). Implement TryRenderAsync method that takes PNG stream, decodes with ImageSharp, creates WriteableBitmap, copies pixels, returns ImageSource. Set StrategyName = "WriteableBitmap + ImageSharp", Priority = 0. Add comprehensive error handling and return null on any failure. | Restrictions: Do not modify PdfViewerViewModel yet (will be done in integration task), keep strategy completely stateless, ensure thread-safe implementation, handle all ImageSharp exceptions gracefully, do not log directly (caller will log), follow existing service patterns, use System.Runtime.InteropServices.WindowsRuntime for AsStream extension | Success: Strategy implements IRenderingStrategy correctly, TryRenderAsync successfully renders PNG stream to WriteableBitmap, error handling is comprehensive and returns null on failure, strategy is stateless and reusable, no memory leaks, follows existing patterns. After implementing, update tasks.md to mark this task as [-] in progress, then use log-implementation tool to record the strategy class created, then mark task as [x] completed._

- [x] 6. Implement FileBasedRenderingStrategy fallback
  - File: src/FluentPDF.App/Services/RenderingStrategies/FileBasedRenderingStrategy.cs
  - Implement strategy that saves PNG to temp file and loads via BitmapImage with file URI
  - Set Priority = 10 (fallback priority)
  - Implement cleanup of temp files (maybe use TTL cache or cleanup on app exit)
  - Purpose: Reliable fallback that avoids InMemoryRandomAccessStream WinUI bug
  - _Leverage: Path.GetTempPath(), BitmapImage with UriSource pattern_
  - _Requirements: 2_
  - _Prompt: Implement the task for spec pdf-rendering-reliability, first run spec-workflow-guide to get the workflow guide then implement the task: Role: .NET Developer with expertise in file I/O and WinUI image loading | Task: Implement FileBasedRenderingStrategy in src/FluentPDF.App/Services/RenderingStrategies/FileBasedRenderingStrategy.cs following requirement 2. Implement TryRenderAsync that: 1) Generates temp file path in Path.GetTempPath() with .png extension and GUID name, 2) Writes PNG stream to temp file, 3) Creates BitmapImage with UriSource = new Uri(tempFilePath), 4) Returns BitmapImage as ImageSource. Set StrategyName = "FileBased", Priority = 10. Add mechanism to track temp files for cleanup (use static ConcurrentBag<string> or similar). Implement cleanup method called on strategy disposal or app exit. | Restrictions: Ensure temp files have unique names (use Guid.NewGuid()), handle file I/O exceptions gracefully and return null, do not leak temp files (must clean up eventually), ensure thread-safe file operations, do not block rendering thread with synchronous I/O where avoidable, follow existing patterns | Success: Strategy successfully saves PNG and loads via file URI, fallback works when WriteableBitmap fails, temp files are eventually cleaned up, no file I/O errors crash application, strategy returns valid ImageSource or null. After implementing, update tasks.md to mark this task as [-] in progress, then use log-implementation tool to record the fallback strategy class, then mark task as [x] completed._

- [x] 7. Implement RenderingStrategyFactory and RenderingCoordinator
  - Files: src/FluentPDF.App/Services/RenderingStrategyFactory.cs, src/FluentPDF.App/Services/RenderingCoordinator.cs
  - RenderingStrategyFactory: Creates and orders strategies by priority
  - RenderingCoordinator: Orchestrates rendering with fallback logic, integrates with RenderingObservabilityService
  - Implement RenderWithFallbackAsync that tries strategies in priority order
  - Purpose: Central orchestration of rendering with automatic fallback
  - _Leverage: Existing PdfRenderingService for PNG generation, factory pattern_
  - _Requirements: 2_
  - _Prompt: Implement the task for spec pdf-rendering-reliability, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Software Architect specializing in coordinator pattern and fault tolerance | Task: Implement two classes following requirement 2: RenderingStrategyFactory in src/FluentPDF.App/Services/RenderingStrategyFactory.cs and RenderingCoordinator in src/FluentPDF.App/Services/RenderingCoordinator.cs. Factory: Inject all IRenderingStrategy implementations via IEnumerable<IRenderingStrategy>, implement GetStrategies() that returns strategies ordered by Priority. Coordinator: Inject RenderingStrategyFactory, RenderingObservabilityService, PdfRenderingService. Implement RenderWithFallbackAsync(pageNumber, context) that: 1) Calls PdfRenderingService.RenderPageAsync to get PNG stream, 2) Uses BeginRenderOperation for timing, 3) Iterates through strategies calling TryRenderAsync, 4) Logs success/failure for each attempt, 5) Returns first successful ImageSource or null if all fail. | Restrictions: Do not modify PdfRenderingService, keep coordinator stateless, ensure proper disposal of PNG streams, log all strategy attempts, do not swallow exceptions without logging, follow existing service patterns, ensure thread-safe operations | Success: Factory correctly orders strategies by priority, coordinator successfully falls back to next strategy when one fails, observability logging captures all attempts, first working strategy is used, null returned only if all strategies fail, comprehensive error logging. After implementing, update tasks.md to mark this task as [-] in progress, then use log-implementation tool to record both factory and coordinator classes, then mark task as [x] completed._

- [x] 8. Register rendering strategies in DI container
  - File: src/FluentPDF.App/App.xaml.cs
  - Register WriteableBitmapRenderingStrategy and FileBasedRenderingStrategy as transient
  - Register RenderingStrategyFactory as singleton
  - Register RenderingCoordinator as singleton
  - Purpose: Wire up strategy pattern in DI for injection
  - _Leverage: Existing DI container registration patterns_
  - _Requirements: 2_
  - _Prompt: Implement the task for spec pdf-rendering-reliability, first run spec-workflow-guide to get the workflow guide then implement the task: Role: .NET Developer with DI container expertise | Task: Register rendering strategies and related services in App.xaml.cs ConfigureServices method following requirement 2. Add: services.AddTransient<IRenderingStrategy, WriteableBitmapRenderingStrategy>(), services.AddTransient<IRenderingStrategy, FileBasedRenderingStrategy>(), services.AddSingleton<RenderingStrategyFactory>(), services.AddSingleton<RenderingCoordinator>(). Ensure strategies are registered as transient (new instance per use) and factory/coordinator as singleton. | Restrictions: Do not modify existing registrations, maintain correct service lifetimes, ensure IEnumerable<IRenderingStrategy> injection resolves all registered strategies, follow existing patterns, keep registration code organized | Success: All strategies and services are properly registered, factory receives all strategies via IEnumerable injection, coordinator resolves correctly, application builds and runs without DI errors. After implementing, update tasks.md to mark this task as [-] in progress, then use log-implementation tool to record DI registrations, then mark task as [x] completed._

## Phase 3: UI Verification

- [x] 9. Implement UIBindingVerifier
  - File: src/FluentPDF.App/Services/UIBindingVerifier.cs
  - Implement VerifyPropertyUpdateAsync that listens for PropertyChanged event with timeout
  - Implement VerifyImageControlUpdateAsync that checks Image.Source property on UI thread
  - Purpose: Detect when UI bindings fail to update after property changes
  - _Leverage: INotifyPropertyChanged pattern, WinUI DispatcherQueue, PropertyChanged events_
  - _Requirements: 3_
  - _Prompt: Implement the task for spec pdf-rendering-reliability, first run spec-workflow-guide to get the workflow guide then implement the task: Role: WinUI Developer specializing in MVVM and data binding | Task: Implement UIBindingVerifier in src/FluentPDF.App/Services/UIBindingVerifier.cs following requirement 3. Implement VerifyPropertyUpdateAsync<T>(INotifyPropertyChanged viewModel, string propertyName, TimeSpan timeout) that: 1) Subscribes to PropertyChanged event, 2) Waits for event with matching propertyName, 3) Returns true if event fires within timeout, false otherwise. Implement VerifyImageControlUpdateAsync(Image control, TimeSpan timeout) that: 1) Uses DispatcherQueue to check control.Source on UI thread, 2) Polls every 100ms up to timeout, 3) Returns true if Source becomes non-null. Use TaskCompletionSource for async waiting. | Restrictions: Must properly unsubscribe from PropertyChanged events to avoid leaks, ensure thread-safe event handling, do not block UI thread, use DispatcherQueue.TryEnqueue for UI thread access, handle timeout gracefully, follow existing service patterns, do not reference specific ViewModels (keep generic) | Success: VerifyPropertyUpdateAsync correctly detects PropertyChanged events, VerifyImageControlUpdateAsync works on UI thread safely, both methods respect timeout parameter, no memory leaks from event subscriptions, service is reusable and thread-safe. After implementing, update tasks.md to mark this task as [-] in progress, then use log-implementation tool to record UIBindingVerifier class and its methods, then mark task as [x] completed._

- [ ] 10. Integrate rendering coordinator and UI verification into ViewModels
  - Files: src/FluentPDF.App/ViewModels/PdfViewerViewModel.cs, src/FluentPDF.App/ViewModels/ThumbnailsViewModel.cs
  - Replace direct rendering calls with RenderingCoordinator.RenderWithFallbackAsync
  - Add UIBindingVerifier calls after setting CurrentPageImage and Thumbnail properties
  - Implement forced UI refresh on verification failure
  - Purpose: Complete integration of reliability features into rendering pipeline
  - _Leverage: Existing ViewModel patterns, PropertyChanged infrastructure_
  - _Requirements: 2, 3_
  - _Prompt: Implement the task for spec pdf-rendering-reliability, first run spec-workflow-guide to get the workflow guide then implement the task: Role: WinUI/MVVM Developer with expertise in ViewModel integration | Task: Integrate RenderingCoordinator and UIBindingVerifier into PdfViewerViewModel and ThumbnailsViewModel following requirements 2 and 3. In PdfViewerViewModel: 1) Inject RenderingCoordinator and UIBindingVerifier, 2) Replace current WriteableBitmap rendering code with await RenderingCoordinator.RenderWithFallbackAsync(currentPage, context), 3) After setting CurrentPageImage, call UIBindingVerifier.VerifyPropertyUpdateAsync(this, nameof(CurrentPageImage), TimeSpan.FromMilliseconds(500)), 4) If verification fails, log warning and call OnPropertyChanged(nameof(CurrentPageImage)) again. Apply similar changes to ThumbnailsViewModel for thumbnail rendering. Remove old debug logging statements. Create RenderContext from current state. | Restrictions: Do not break existing rendering pipeline, maintain backward compatibility with current features, ensure proper disposal of services, do not introduce performance regressions, remove temporary debug code, follow existing ViewModel patterns, handle all error cases gracefully | Success: ViewModels use RenderingCoordinator for all rendering, UI verification automatically detects binding failures, forced refresh recovers from verification failures, all existing features still work, rendering is more reliable with fallbacks, debug logging is removed. After implementing, update tasks.md to mark this task as [-] in progress, then use log-implementation tool to record ViewModel changes and integration points, then mark task as [x] completed._

## Phase 4: CLI Enhancements

- [ ] 11. Extend CommandLineOptions with diagnostic commands
  - File: src/FluentPDF.App/CommandLineOptions.cs
  - Add properties: TestRender, Diagnostics, Verbose, RenderTest, OutputDirectory, CaptureCrashDump
  - Add command line argument parsing for new options
  - Purpose: Support new CLI diagnostic commands
  - _Leverage: Existing CommandLineParser.Default.ParseArguments pattern_
  - _Requirements: 4_
  - _Prompt: Implement the task for spec pdf-rendering-reliability, first run spec-workflow-guide to get the workflow guide then implement the task: Role: .NET Developer with CLI application expertise | Task: Extend CommandLineOptions class in src/FluentPDF.App/CommandLineOptions.cs with new diagnostic command options following requirement 4. Add properties: [Option("test-render")] public string? TestRender, [Option("diagnostics")] public bool Diagnostics, [Option("verbose")] public bool Verbose, [Option("render-test")] public string? RenderTest, [Option("output")] public string? OutputDirectory, [Option("capture-crash-dump")] public bool CaptureCrashDump. Add XML documentation for each option explaining its purpose. | Restrictions: Do not break existing command line parsing, maintain compatibility with current options (OpenFile, AutoClose, Console), follow existing CommandLineParser attribute patterns, keep option names lowercase with hyphens, ensure bool options work without values, validate that file options reference valid paths | Success: All new options are correctly defined with CommandLineParser attributes, options parse correctly from command line arguments, documentation is clear and helpful, existing options still work, no breaking changes to CLI interface. After implementing, update tasks.md to mark this task as [-] in progress, then use log-implementation tool to record the new CLI options added, then mark task as [x] completed._

- [ ] 12. Implement CLI diagnostic command handlers
  - File: src/FluentPDF.App/Services/DiagnosticCommandHandler.cs
  - Implement HandleTestRenderAsync: Load PDF, render first page, save diagnostic info, return exit code
  - Implement HandleDiagnosticsAsync: Output system info, PDFium version, WinUI version, capabilities
  - Implement HandleRenderTestAsync: Render all pages to PNG files in output directory
  - Purpose: Execute diagnostic commands requested via CLI
  - _Leverage: Existing PdfDocumentService, PdfRenderingService, RenderingCoordinator_
  - _Requirements: 4_
  - _Prompt: Implement the task for spec pdf-rendering-reliability, first run spec-workflow-guide to get the workflow guide then implement the task: Role: .NET Developer specializing in CLI tools and diagnostics | Task: Implement DiagnosticCommandHandler in src/FluentPDF.App/Services/DiagnosticCommandHandler.cs following requirement 4. Inject PdfDocumentService, RenderingCoordinator, RenderingObservabilityService. Implement three async methods: 1) HandleTestRenderAsync(filePath) - loads PDF, renders first page with RenderingCoordinator, saves diagnostic output to file, returns 0 on success or error code (1=load fail, 2=render fail, 3=UI fail), 2) HandleDiagnosticsAsync() - writes system info to console (OS version, .NET version, memory, PDFium version via PdfiumInterop), returns 0, 3) HandleRenderTestAsync(filePath, outputDir) - loads PDF, renders all pages, saves PNGs to outputDir with naming pattern "page_{pageNum}.png", returns 0 on success. All methods should write progress to Console.WriteLine for user feedback. | Restrictions: Do not create UI windows in CLI mode, ensure proper error handling and logging, write user-friendly console output, validate file paths before use, handle missing directories, ensure clean exit codes, do not depend on WinUI UI thread in CLI mode, follow async/await patterns, dispose resources properly | Success: All three handlers work correctly from CLI, test-render produces diagnostic file and correct exit code, diagnostics outputs complete system information, render-test generates all PNG files successfully, console output is clear and informative, error handling is robust. After implementing, update tasks.md to mark this task as [-] in progress, then use log-implementation tool to record DiagnosticCommandHandler class and all methods, then mark task as [x] completed._

- [ ] 13. Wire CLI command handlers to App startup
  - File: src/FluentPDF.App/App.xaml.cs
  - Modify OnLaunched to detect CLI diagnostic commands and route to handlers
  - Execute command handler and call Application.Exit with appropriate exit code
  - Skip UI initialization when running CLI diagnostic commands
  - Purpose: Execute diagnostic commands before UI startup
  - _Leverage: Existing command line parsing in OnLaunched, Application.Exit pattern_
  - _Requirements: 4_
  - _Prompt: Implement the task for spec pdf-rendering-reliability, first run spec-workflow-guide to get the workflow guide then implement the task: Role: WinUI Application Developer with startup pipeline expertise | Task: Modify App.xaml.cs OnLaunched method to handle CLI diagnostic commands following requirement 4. After parsing CommandLineOptions, check for diagnostic commands (TestRender, Diagnostics, RenderTest). If any diagnostic command is present: 1) Resolve DiagnosticCommandHandler from DI container (may need to build host first), 2) Execute appropriate handler method, 3) Capture exit code, 4) Call Application.Exit() or Environment.Exit() with exit code, 5) Return early without creating main window. Ensure verbose mode enables maximum Serilog logging level. | Restrictions: Do not break normal application startup when no CLI commands present, ensure proper DI container initialization before resolving handler, handle errors in command execution gracefully, log errors to console in CLI mode, maintain backward compatibility with existing CLI behavior (OpenFile, AutoClose), ensure clean process termination with correct exit codes | Success: CLI diagnostic commands execute before UI startup, application exits cleanly with correct exit code, verbose mode increases logging verbosity, normal application startup still works when no CLI commands, error handling is comprehensive, no UI windows flash during CLI execution. After implementing, update tasks.md to mark this task as [-] in progress, then use log-implementation tool to record App.xaml.cs integration changes, then mark task as [x] completed._

## Phase 5: Testing and Validation

- [ ] 14. Write integration tests for rendering reliability
  - File: tests/FluentPDF.App.Tests/Integration/RenderingReliabilityTests.cs
  - Test RenderingCoordinator fallback logic with real PDF
  - Test MemoryMonitor detects memory usage correctly
  - Test UIBindingVerifier detects property changes
  - Test all rendering strategies individually
  - Purpose: Validate rendering reliability features work correctly
  - _Leverage: Existing test infrastructure, test PDF files in test resources_
  - _Requirements: 1, 2, 3, 5_
  - _Prompt: Implement the task for spec pdf-rendering-reliability, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer specializing in integration testing and xUnit | Task: Create comprehensive integration tests in tests/FluentPDF.App.Tests/Integration/RenderingReliabilityTests.cs covering requirements 1, 2, 3, 5. Use xUnit test framework. Write tests: 1) Test_RenderingCoordinator_FallsBackToFileBasedStrategy - Mock WriteableBitmapStrategy to fail, verify FileBasedStrategy succeeds, 2) Test_MemoryMonitor_CapturesSnapshotAccurately - Capture snapshot, allocate known memory, capture again, verify delta, 3) Test_UIBindingVerifier_DetectsPropertyChange - Create mock ViewModel, fire PropertyChanged, verify detection, 4) Test_WriteableBitmapStrategy_RendersSuccessfully - Render test PDF page with strategy, verify ImageSource returned, 5) Test_FileBasedStrategy_CreatesTempFile - Render with FileBasedStrategy, verify temp file exists and is valid PNG. Use existing test utilities and test PDFs from FluentPDF.App.Tests. | Restrictions: Do not test private implementation details, test through public interfaces, use proper test isolation (cleanup temp files, reset mocks), ensure tests run in any order, do not depend on external state, follow existing test patterns in FluentPDF.App.Tests, use async tests where appropriate, ensure tests are deterministic | Success: All integration tests pass reliably, tests cover key reliability features, tests provide good failure diagnostics, test code is maintainable and follows patterns, no flaky tests, good code coverage of new features. After implementing, update tasks.md to mark this task as [-] in progress, then use log-implementation tool to record test class and all test methods created, then mark task as [x] completed._

- [ ] 15. Write E2E tests for PDF rendering and display verification
  - File: tests/FluentPDF.E2E.Tests/Tests/RenderingDisplayTests.cs
  - Test PDF opens and displays image within timeout
  - Test visual verification that Image control contains rendered content
  - Test thumbnail grid populates with images
  - Test CLI test-render command produces correct output
  - Purpose: Validate end-to-end user experience for PDF rendering
  - _Leverage: Existing FlaUI E2E test infrastructure, test PDF files_
  - _Requirements: 6_
  - _Prompt: Implement the task for spec pdf-rendering-reliability, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Automation Engineer specializing in UI testing and FlaUI | Task: Create E2E tests in tests/FluentPDF.E2E.Tests/Tests/RenderingDisplayTests.cs following requirement 6. Use existing FlaUI test base class. Write tests: 1) Test_PdfOpens_AndDisplaysImage_WithinTimeout - Launch app with test PDF, wait up to 5 seconds, verify Image control Source is not null using UI Automation, 2) Test_ImageControl_ContainsNonBlankContent - Load PDF, capture screenshot of Image control, verify pixels are not all white/blank, 3) Test_ThumbnailGrid_PopulatesWithImages - Open multi-page PDF, verify thumbnail grid contains thumbnail items with images, 4) Test_CliTestRender_Succeeds - Launch FluentPDF.App.exe with --test-render flag via Process.Start, verify exit code 0, verify diagnostic output file created. Use existing E2E test patterns and utilities. | Restrictions: Ensure proper application lifecycle (start/stop) in each test, cleanup temp files and processes, handle test timeouts gracefully, do not assume specific UI layout (use robust selectors), follow existing FlaUI patterns in project, ensure tests work in CI environment, properly wait for async operations to complete | Success: All E2E tests pass on local machine and in CI, tests accurately verify UI displays rendered content, tests catch regressions in rendering display, test code is maintainable and reliable, no flaky tests, clear failure messages for debugging. After implementing, update tasks.md to mark this task as [-] in progress, then use log-implementation tool to record E2E test class and all test methods, then mark task as [x] completed._

- [ ] 16. Performance testing and optimization
  - File: tests/FluentPDF.Rendering.Tests/Performance/RenderingReliabilityBenchmarks.cs (new benchmark class)
  - Create benchmarks for observability overhead
  - Verify memory monitoring doesn't regress performance
  - Benchmark fallback rendering performance
  - Purpose: Ensure reliability features don't introduce performance regressions
  - _Leverage: Existing BenchmarkDotNet infrastructure in Performance tests_
  - _Requirements: All (performance NFRs)_
  - _Prompt: Implement the task for spec pdf-rendering-reliability, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Performance Engineer with BenchmarkDotNet expertise | Task: Create performance benchmarks in tests/FluentPDF.Rendering.Tests/Performance/RenderingReliabilityBenchmarks.cs. Use BenchmarkDotNet. Create benchmarks: 1) Benchmark_RenderingWithObservability vs Benchmark_RenderingWithoutObservability - measure overhead of RenderingObservabilityService (should be <50ms), 2) Benchmark_MemoryMonitorSnapshot - measure time to capture memory snapshot (should be <10ms), 3) Benchmark_WriteableBitmapStrategy vs Benchmark_FileBasedStrategy - compare performance of two strategies, 4) Benchmark_UIBindingVerification - measure verification overhead (should be <500ms). Use realistic test PDF with multiple pages. Follow existing benchmark patterns in FluentPDF.Rendering.Tests. | Restrictions: Use BenchmarkDotNet attributes correctly ([Benchmark], [MemoryDiagnoser]), ensure benchmarks are isolated and repeatable, do not include test setup in benchmark timing, use realistic workloads, follow existing benchmark structure, handle resource cleanup properly, ensure benchmarks run in release mode | Success: All benchmarks run successfully, observability overhead is within acceptable limits (<50ms), memory monitoring is lightweight (<10ms), benchmarks provide actionable performance data, no performance regressions detected, benchmark code is maintainable. After implementing, update tasks.md to mark this task as [-] in progress, then use log-implementation tool to record benchmark class created, then mark task as [x] completed._

- [ ] 17. Documentation and cleanup
  - Files: Update CLAUDE.md, add docs/RENDERING_RELIABILITY.md, remove debug logging
  - Document new CLI commands in CLAUDE.md
  - Create comprehensive guide for troubleshooting rendering issues
  - Remove all temporary debug logging (System.IO.File.AppendAllText statements)
  - Document architecture decisions and fallback strategies
  - Purpose: Ensure features are documented and code is production-ready
  - _Leverage: Existing documentation structure_
  - _Requirements: All_
  - _Prompt: Implement the task for spec pdf-rendering-reliability, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Technical Writer and .NET Developer | Task: Complete documentation and cleanup following all requirements. 1) Update CLAUDE.md with new CLI diagnostic commands (--test-render, --diagnostics, --verbose, --render-test, --output), 2) Create comprehensive rendering reliability guide at docs/RENDERING_RELIABILITY.md explaining architecture, fallback strategies, troubleshooting steps, diagnostic commands, common issues and solutions, 3) Search entire codebase for System.IO.File.AppendAllText and remove all temporary debug logging statements from PdfViewerViewModel.cs, ThumbnailsViewModel.cs, and any other files, 4) Add XML documentation to all public APIs in new classes, 5) Verify all code follows project style and conventions. | Restrictions: Do not remove Serilog structured logging (only remove temp debug file logging), ensure documentation is clear and user-friendly, maintain existing CLAUDE.md structure, do not break any functionality during cleanup, preserve important comments and documentation, follow existing documentation patterns | Success: CLAUDE.md updated with accurate CLI documentation, RENDERING_RELIABILITY.md is comprehensive and helpful, all temporary debug logging removed, code is clean and production-ready, XML documentation is complete, no functionality broken during cleanup. After implementing, update tasks.md to mark this task as [-] in progress, then use log-implementation tool to record documentation files created/updated and cleanup performed, then mark task as [x] completed._
